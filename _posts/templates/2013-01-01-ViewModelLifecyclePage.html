
        <p>It is important to know the view model lifecycle and where to put code. Below is a simple test to show the lifecycle of events within a view model</p>
        <Wipeout.Docs.ViewModels.Components.JsCodeBlock>
            <code>window.testNamespace = {};
// view model to collect data
testNamespace.testClass = wo.view.extend(function() {
    // call the parent constructor
    this._super(wo.visual.getBlankTemplateId());
    
    // create a place to store the events which occur
    this.setupEvents = ko.observableArray([]);
    this.disposeEvents = ko.observableArray([]);
    
    // signal that the constructor was called
    this.registerEvent({name: "Constructor", description: "The object constructor. At this stage no properties\
    have been set and the object has not been rendered"});
}, "testClass");

// override each hook and add it to the events called
testNamespace.testClass.prototype.dispose = function () {
    this.registerEvent({name: "dispose", description: "At this point the object is about to be disposed. A\
    disposed object cannot be used anymore"});
    
    this._super();
};

testNamespace.testClass.prototype.initialize = function(propertiesXml, parentBindingContext) {
    this.registerEvent({name: "initialize", description: "The object is about to be initialized. After this\
    method the items properties will be set, but not its templateItems. The item has not been rendered yet."});
    
    this._super(propertiesXml, parentBindingContext);
};

testNamespace.testClass.prototype.onApplicationInitialized = function () {
    this.registerEvent({name: "onApplicationInitialized", description: "This is called once if the view\
    model is an application root (used with the wipeout binding). It is called after everything\
    has been set and rendered"});
    
    this._super(propertiesXml, parentBindingContext);
};

testNamespace.testClass.prototype.onInitialized = function () {    
    this.registerEvent({name: "onInitialized", description: "This is called after the initialize\
    function has fired."});
    
    this._super();
};

testNamespace.testClass.prototype.onModelChanged = function (oldVal, newVal) {
    this.registerEvent({name: "onModelChanged", description: "This method is fired each time\
    the model changes. It should be used to operate on a model and to dispose of operations on an old model"});
    
    this._super(oldVal, newVal);
};

testNamespace.testClass.prototype.onRendered = function (newValues, oldValues) {
    this.registerEvent({name: "onRendered", description: "This is called after an item is renered.\
    It supplies an array of nodes deleted and nodes created during the rendering process"});
    
    this._super(newValues, oldValues);
};

testNamespace.testClass.prototype.onUnrender = function () {
    this.registerEvent({name: "onUnrender", description: "This is called after the item is unRendered."});
    
    this._super();
};

testNamespace.testClass.prototype.unRender = function () {
    this.registerEvent({name: "unRender", description: "This is called when the item is unRendered.\
    Un rendering is the process of removing a template from an item, disposing of template related\
    items and removing the template-less view model from the view hirearchy."});
    
    this._super();    
};

testNamespace.testClass.prototype.unTemplate = function () {    
    this.registerEvent({name: "unTemplate", description: "This is called when the item is unTemplated.\
    Un templating gives the item a blank template and disposes of template related items."});
    
    this._super();
};

testNamespace.testClass.prototype.registerEvent = function(event) {
    if(this.disposing)
        this.disposeEvents.push(event);
    else
        this.setupEvents.push(event);
}

// view model to display data
testNamespace.testClassRunner = wo.view.extend(function() {
    // call the parent constructor
    this._super("testNamespace.testClassRunner");
    
    // create a place to store the events which occur
    this.events = ko.observableArray([]);
}, "testNamespace");

// when all rendering is complete, dispose of the test instance to see the order of disposal events
testNamespace.testClassRunner.prototype.onRendered = function(oldValues, newValues) {
    this._super(oldValues, newValues);
    
    // tell the child to place events on the dispose queue from now on
    this.templateItems.testClass_instance.disposing = true;
    this.templateItems.testClass_instance.dispose();
};</code>
        </Wipeout.Docs.ViewModels.Components.JsCodeBlock>
        <p>With template:</p>
        <Wipeout.Docs.ViewModels.Components.TemplateCodeBlock>
            <code>&lt;script type="text/xml" id="testNamespace.testClassRunner">
    &lt;h3>Order of events&lt;/h3>
    &lt;p>The order denotes the order functions are called in, not the order functions are 
    finished execution in. Placing the &lt;code>_super(...)&lt;/code> call before the 
    event registation would yield a slightly different order.&lt;/p>
    &lt;!-- Create the target view model which will be monitored -->
    &lt;testNamespace.testClass id="testClass_instance" />
    
    &lt;h3>Creating:&lt;/h3>
    &lt;!-- Display setup function calls -->
    &lt;wo.itemsControl itemSource="$parent.templateItems.testClass_instance.setupEvents">
        &lt;template>
            &lt;table class="table">             
                &lt;thead>
                    &lt;tr>
                        &lt;th>Order&lt;/th>
                        &lt;th>Function&lt;/th>
                        &lt;th>Description&lt;/th>
                    &lt;/tr>
                &lt;/thead>
                &lt;tbody data-bind="itemsControl: null">
                &lt;/tbody>
            &lt;/table>
        &lt;/template>
        &lt;itemTemplate>
            &lt;tr>
                &lt;td data-bind="text: $parent.items.indexOf($data) + 1">&lt;/td>
                &lt;td data-bind="text: model().name">&lt;/td>
                &lt;td data-bind="text: model().description">&lt;/td>
            &lt;/tr>
        &lt;/itemTemplate>
    &lt;/wo.itemsControl>
    
    &lt;!-- Display dispose function calls -->
    &lt;h3>Disposing:&lt;/h3>
    &lt;wo.itemsControl itemSource="$parent.templateItems.testClass_instance.disposeEvents">
        &lt;template>
            &lt;table class="table">             
                &lt;thead>
                    &lt;tr>
                        &lt;th>Order&lt;/th>
                        &lt;th>Function&lt;/th>
                        &lt;th>Description&lt;/th>
                    &lt;/tr>
                &lt;/thead>
                &lt;tbody data-bind="itemsControl: null">
                &lt;/tbody>
            &lt;/table>
        &lt;/template>
        &lt;itemTemplate>
            &lt;tr>
                &lt;td data-bind="text: $parent.items.indexOf($data) + 1">&lt;/td>
                &lt;td data-bind="text: model().name">&lt;/td>
                &lt;td data-bind="text: model().description">&lt;/td>
            &lt;/tr>
        &lt;/itemTemplate>
    &lt;/wo.itemsControl>
&lt;/script></code>
        </Wipeout.Docs.ViewModels.Components.TemplateCodeBlock>
        <Wipeout.Docs.ViewModels.Components.UsageCodeBlock showDefinitionCode="false">
            <code>&lt;testNamespace.testClassRunner /></code>
        </Wipeout.Docs.ViewModels.Components.UsageCodeBlock>